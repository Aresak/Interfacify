using Microsoft.CodeAnalysis;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;

namespace Aresak.Interfacify.Data;

/// <summary>
/// Contains metadata about a class that can be used by templates.
/// </summary>
internal record ClassMetadata : Metadata
{
    /// <summary>
    /// Namespace of the class.
    /// </summary>
    public string Namespace = string.Empty;

    /// <summary>
    /// Properties or fields of the class that has to be generated by a template.
    /// </summary>
    public List<PropertyMetadata> Properties = [];

    /// <summary>
    /// Whether the class is an interface (yeah, it doesn't make sense to call it a class now, does it?).
    /// </summary>
    public bool IsInterface { get; }

    /// <summary>
    /// Members declared in the class.
    /// Either by the class implementation or generated by a template.
    /// </summary>
    List<string> declaredMembers = [];

    /// <summary>
    /// Creates a new instance of <see cref="ClassMetadata"/>.
    /// </summary>
    /// <param name="classSymbol">Class containing generating attribute</param>
    public ClassMetadata(INamedTypeSymbol classSymbol)
    {
        Accessibility = classSymbol.DeclaredAccessibility;
        Name = classSymbol.Name;
        Namespace = classSymbol.ContainingNamespace.ToString();
        IsInterface = classSymbol.TypeKind == TypeKind.Interface;

        // Set declared members to properties and fields declared in the class.
        if (!IsInterface)
        {
            declaredMembers = classSymbol.MemberNames.ToList();
        }

        // Add properties from interfaces.
        ProcessInterfaceMembers(classSymbol);
    }

    /// <summary>
    /// Adds properties from interfaces implemented by the class.
    /// </summary>
    /// <param name="classSymbol">Class containing generating attribute</param>
    void ProcessInterfaceMembers(INamedTypeSymbol classSymbol)
    {
        if (classSymbol.TypeKind == TypeKind.Interface)
        {
            // If the class is an interface, add properties from its base interfaces.
            ProcessMembers(classSymbol);
        }

        foreach (INamedTypeSymbol interfaceSymbol in classSymbol.AllInterfaces)
        {
            ProcessMembers(interfaceSymbol);
        }
    }

    /// <summary>
    /// Process members of a class or interface.
    /// </summary>
    /// <param name="classSymbol">Class or interface to add properties from</param>
    void ProcessMembers(INamedTypeSymbol classSymbol)
    {
        ImmutableArray<ISymbol> members = classSymbol.GetMembers();

        foreach (ISymbol member in members)
        {
            if (member is not IPropertySymbol property || declaredMembers.Contains(property.Name))
            {
                // Skip if member is not a property or if the property is already declared.
                continue;
            }

            AddGeneratedProperty(property);
        }
    }

    /// <summary>
    /// Adds a property to be generated.
    /// </summary>
    /// <param name="property">Property to be generated</param>
    void AddGeneratedProperty(IPropertySymbol property)
    {
        PropertyMetadata propertyMetadata = new(property);
        Properties.Add(propertyMetadata);
        declaredMembers.Add(property.Name);
    }
}
