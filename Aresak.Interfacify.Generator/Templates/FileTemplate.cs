using Aresak.Interfacify.Data;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using System.Text;

namespace Aresak.Interfacify.Templates;

/// <summary>
/// Basic file template for the generated files.
/// </summary>
/// <param name="metadata"></param>
internal class FileTemplate(ClassMetadata metadata)
{
    /// <summary>
    /// Metadata accessible also for other templates.
    /// </summary>
    protected ClassMetadata Metadata => metadata;

    /// <summary> 
    /// Generates the source code for the file.
    /// </summary>
    /// <returns>Full source code for the file</returns>
    public virtual string GenerateFile()
    {
        TemplateData data = GetTemplateData();

        // TODO: Specify the version in the [GeneratedCode] attribute
        // by Assembly version.

        string code = $@"
            // <auto-generated>
            //     Interfacify
            // </auto-generated>
            #pragma warning disable CS8669

            using System.CodeDom.Compiler;
            {data.Usings}

            namespace {Metadata.Namespace}
            {{
                {data.Attributes}
                [GeneratedCode(""Interfacify"", ""1.1.2"")]
                {Metadata.AccessibilityToString()} partial class {data.ClassName} {data.ClassNameSuffix}
                {{
                    {data.AdditionalCode}
                    {data.Properties}
                }}
            }}
            ";

        code = ArrangeUsingRoslyn(code);

        return code;
    }

    /// <summary>
    /// Generates the source code for the property.
    /// </summary>
    /// <param name="property">Property to be generated</param>
    /// <returns>Full source code of the property</returns>
    protected virtual string GenerateProperty(PropertyMetadata property)
    {
        PropertyTemplate template = new(property);
        return template.Generate();
    }

    /// <summary>
    /// Generates the source code for the using statements.
    /// </summary>
    /// <returns>All usings that will be added to the full source code</returns>
    protected virtual string AddUsingStatements()
    {
        return string.Empty;
    }

    /// <summary>
    /// Generates the source code that will be placed in the class.
    /// </summary>
    /// <returns>Full source code that should be in the class</returns>
    protected virtual string AddAdditionalClassCode()
    {
        return string.Empty;
    }

    /// <summary>
    /// Genereates the source code for the class attributes.
    /// </summary>
    /// <returns>Full source code of attributes that will be prepended before the class definition</returns>
    protected virtual string AddClassAttributes()
    {
        return string.Empty;
    }

    /// <summary>
    /// Generates a class name based.
    /// </summary>
    /// <returns>The class name to be used</returns>
    protected virtual string GenerateClassName()
    {
        if (Metadata.IsInterface)
        {
            if (Metadata.Name.Length > 1 && Metadata.Name[0] == 'I' && char.IsUpper(Metadata.Name[1]))
            {
                return Metadata.Name.Substring(1);
            }
            else
            {
                return Metadata.Name + "Class";
            }
        }

        return Metadata.Name;
    }

    protected virtual string GenerateClassNameSuffix()
    {
        if (Metadata.IsInterface)
        {
            return $": {Metadata.Name}";
        }

        return string.Empty;
    }

    /// <summary>
    /// Generates the source code for all properties.
    /// </summary>
    /// <returns>Full source code of all properties</returns>
    protected string GenerateProperties()
    {
        StringBuilder stringBuilder = new();

        foreach (PropertyMetadata property in Metadata.Properties)
        {
            string propertySource = GenerateProperty(property);
            stringBuilder.AppendLine(propertySource);
        }

        return stringBuilder.ToString();
    }

    TemplateData GetTemplateData()
    {
        string properties = GenerateProperties();
        string usings = AddUsingStatements();
        string attributes = AddClassAttributes();
        string additionalCode = AddAdditionalClassCode();
        string className = GenerateClassName();
        string classNameSuffix = GenerateClassNameSuffix();

        return new TemplateData
        {
            Properties = properties,
            Usings = usings,
            Attributes = attributes,
            AdditionalCode = additionalCode,
            ClassName = className,
            ClassNameSuffix = classNameSuffix
        };
    }

    /// <summary>
    /// Arranges the source code using Roslyn.
    /// </summary>
    /// <param name="csCode">Full source code to be formatted</param>
    /// <returns>Formatted source code</returns>
    protected static string ArrangeUsingRoslyn(string csCode)
    {
        SyntaxTree tree = CSharpSyntaxTree.ParseText(csCode);
        SyntaxNode root = tree.GetRoot().NormalizeWhitespace();
        string ret = root.ToFullString();

        return ret;
    }

    struct TemplateData
    {
        public string Properties { get; set; }

        public string Usings { get; set; }

        public string Attributes { get; set; }

        public string AdditionalCode { get; set; }

        public string ClassName { get; set; }

        public string ClassNameSuffix { get; set; }
    }
}
